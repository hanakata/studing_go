第5章 構造体とインターフェース

■ポインタ
ポインタとは？
値型に分類されるデータ構造のメモリ上のアドレスと型の情報。
これを使ってデータ構造を間接的に参照、操作できる。

・ポインタの定義
ポインタ型は*intのようにポインタを使って参照・操作する方の前に*を置くことで定義できる。
定義のみしたポインタ型の変数の初期値はnil。

・アドレス演算子とデリファレンス
演算子&を使って任意の型からそのポインタ型を生成することが出来る。
演算子&はアドレス演算子とも呼ばれる。
演算子*をポインタ型の変数の前に置くことでポインタ型が指し示すデータのデリファレンスをすることが出来る。
デリファレンスとは？
ポインタ型が保持するメモリ上のアドレスを経由してデータ本体を参照するための仕組み。
例としてint型の変数iとそれを指すポインタ変数pが定義されているとき、
*pによりデリファレンスで変数iの値を参照でき、*p = 10で書き換え可能。

var i int // int宣言
p := &i //アドレス演算子によってint型からポインタ型を生成
i = 5
fmt.Println(i) // 5
*p = 10
fmt.Println(i) // 10

関数の引数にint型のような値型を渡す場合は関数呼び出しの際に引数の値のコピーが発生してしまい
同じメモリ領域の値を共有することは出来ない。
ただポインタ型を介すれば関数の間で1つのメモリ上の値を共有することが出来る。

func int (p *int){
    *p++
}

func main(){
    i := 1
    inc(&i)
    inc(&i)
    inc(&i)
    fmt.Println(i) // 4
}

任意の配列に関してもポインタ型を定義出来る。
&[3]int{1,2,3}みたいな感じ。
ポインタ型の変数がnilの場合にデリファレンスするとランタイムパニックが発生するので初期化確認は重要。

・配列へのポインタ型
p := &[3]int{1,2,3}のような感じで配列へのポインタを作成できるが
参照するときはp[i]と書くだけでポインタ型へのデリファレンス→配列型の要素の参照といった処理の組み合わせになる。

・値としてのポインタ型
ポインタ型は型とメモリ上のアドレスを組み合わせたデータ型。
ポインタ型は値としてメモリ上のアドレスを保持する。
なのでアドレスの具体的な値も見ることは出来る。使用頻度は低い。

・文字列型とポインタ
演算子&を使用してString型のポインタをとるのは問題ない。
ただし部分参照を行うとコンパイルエラーが発生する。→Goでは明白に禁止されているため。
Goは一度生成された文字列にたいして何らかの変更を加えることは基本的に出来ない。
ポインタで参照できる＝破壊的変更を許可することに繋がるため。

■構造体
構造体とは？
複数の任意の型の値を1つにまとめたもの。

・Type
予約語Typeの使い方は以下。
type 定義する型 既存の型
これを使うことでint型にMyintのようなエイリアスを定義することが出来る。
利点として、プログラムから複雑な型定義を取り除くことが出来る。
また可読性が上がる。

・エイリアス型の互換性
例えばint型のエイリアスを2つ作った場合、2つともint型との互換性はあるが
お互いの型の互換性はない。

・構造体の定義
構造体を利用するにはtypeと組み合わせて新しい型を定義する。
構造体はstruct { フィールド定義 }によって囲われた範囲で定義する。
例えば
type Point struct{
    X int
    Y int
}
といった形で定義する。

・複合リテラル
構造体の各フィールドの初期値を指定しつつ構造体を生成できる。
{}で囲んだフィールドの初期値を列挙することができ、それぞれの値は構造体
フィールドが定義された順に対応している。
pt := Point{1,2}
フィールドを明示的に指定して値を定義するための複合リテラルもある。
pt := Point{x:1,Y:2}

フィールドの明示的に指定する複合リテラルを利用することでフィールドの1部のみを初期化することが出来る。
基本的にはフィールドを明示的に指定する書き方を選択すべき。

・フィールド定義の詳細
構造体のフィールド名のルールは変数や関数など他の識別子と同じ。
なので日本語もOK。先頭大文字英字が好ましい。

・構造体を含む構造体
以下のような定義が可能。
type Feed struct {
    Name string
    Amount uint
}
type Animal struct{
    Name string
    Feed Feed
}
アクセスするときは階層的に。

フィールド名を省略すると型と同じ名前になる。
アクセスするときにフィールド名を省略できるようになる。
ただし省略したフィールド名にアクセスするときは省略できない。
注意点としてポインタ型を埋め込む場合や別パッケージで定義されているものを
指定する場合はポインタ型の修飾子やパッケージのプリフィックス部分は無視される。

再帰的な定義は禁止。

・無名の構造体型
構造体はtypeと組み合わせて利用するがstruct { フィールド定義 }という
構造体そのものを型として利用することも可能。

func showStruct(s struct{ X, Y int}){
    fmt.Println(s)
}

s := struct{ X,Y int}{X:1,Y:2}
showStruct(s)
のような形で定義できる。

・構造体とポインタ
構造体は値型なので関数の引数として構造体を渡した場合は構造体のコピーが
生成されその構造体が関数によって処理されるので元の構造体には影響を与えられない。
構造体を関数へ参照渡しするために必要になるのが構造体型へのポインタ。
p := &Point{X:1,Y:2}
という形で定義できる。

・new
指定した型のポインタ型を生成するために組み込み関数newが用意されている。使いかたはnew([型])

type Person struct{
    Id int
    Name string
    Area string
}
p := new(Person)
これで構造体のポインタが作成出来る。
&を使っても大して変わりはないのでプログラムの状況に応じて使い分けを行うべき。

■メソッド
任意の型に特化した関数を定義するもの。
type Point struct{
    X,Y int
}
func (p *point) Render(){
    fmt.Printf("<%d,%d>\n",p.X,p.Y)
}

p := &Point{X:5,Y:12}
p.Render

メソッド関数はfuncとメソッド名の間にレシーバが必要。
(p *point)←これ
レシーバ.メソッドという形式で呼び出すことが可能。
p.Render←これ
メソッドの場合はレシーバーの型さえ異なっていれば同名のメソッドを定義できる。
メソッドは構造体型だけではなくエイリアスに対しても定義可能。

・型のコンストラクタ
コンストラクタ機能はないが慣例的に方のコンストラクタというパターンを利用する。
type User struct {
    Id int
    Name string
}

func NewUser(id int, name string) *User{
    u := new(User)
    u.Id = id
    u.Name = name
    return u
}

fmt.Println(NewUser(1,"Taro"))

パッケージ外部に公開する場合はNewUserのようにすれば良いが
基本的にはnewUserのように非公開にするほうが良い。

・関数としてのメソッド
メソッドはレシーバの定義が必要など通常の関数定義とは違うが実体としては関数そのもの。

・レシーバーとポインタ型
メソッドを定義するのに悩むのはレシーバーを値型にするかポインタ型にするか
基本的な原則は構造体に定義するメソッドのレシーバーはポイント型にすべき。
レシーバーに値型が定義されたメソッドでは呼び出し時にレシーバーそのもののコピーが発生する。
それが原因で呼び出し側と内部においてレシーバの実体が変わるのでポインタ型のほうが良い。

・フィールドとメソッドの可視性
外部の関数から参照可能かは先頭の文字が大文字かどうか。

・スライスと構造体
組み込み関数makeと構造体型を組み合わせて構造体型のスライスを作ることができる。
newを使うよりメモリ効率や実行効率の面で有利。

・マップと構造体
マップでも構造体型を利用できる。構造体型をマップのキーにするにせよ値にするにせよリテラル内で構造体型の型名を省略できる。

・タグ
フィールドにメタ情報を付与する機能をタグと呼ぶ。
タグは文字列リテラルかRAW文字列リテラルを利用する。
タグはあくまでもメタ情報なのでプログラム実行には影響を及ぼさない。
タグ情報は表示することが出来る。
タグはあくまで文字列なだけなので間違っていてもコンパイルエラーが出るわけではない。

■インターフェース
インターフェースは型の一種であり任意の型がどのようなメソッドを実装するべきかを規定するための枠組み。

・代表的なインターフェースerror
組み込み型のerrorはインターフェースとして定義されている。
error型は文字列を返すだけ。
インターフェースのメリットは異なる型に共通の性質を付与する使い方。
