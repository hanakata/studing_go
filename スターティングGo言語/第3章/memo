第3章 言語の基本

■コメント
コメントは//もしくは/*AAA*/みたいなかんじ。
コメントの中にコメントを書くことは出来ない。

■文
・セミコロンとその省略
Go言語は各文がセミコロンで区切られる。ただすべてのセミコロンは省略可能。
省略した場合はコンパイラが文末をみて終端と判断されれば自動的に挿入される。
逆にセミコロンをつければ1行で書いても動作はする。
・セミコロンの落とし穴
例えば以下のような場合
a := [3]string{"Yamada Taro","Sato Hanako","Suzuki Kenji"}
これはaという文字列を3つ格納できるに値を保存する部分。
これを見やすくすると以下のようになる。
a := [3]string{"Yamada Taro",
               "Sato Hanako",
               "Suzuki Kenji"
}
こうした場合、コンパイラエラーになる。
その理由は行末が}であったり,でない場合文の終端であると判断するから。
なので以下のように書く必要がある。
a := [3]string{"Yamada Taro",
               "Sato Hanako",
               "Suzuki Kenji",
}

■定義済み識別子
Goにも定義済み識別子はあるが自作の関数や変数でも使うことが出来る。
だが混乱に繋がるので止めた方がよい。

■変数
全ての変数には型がある。型は大きく分けて値型、参照型、ポインタ型。
値型＝整数や実数といった値そのもの
参照型＝スライス、マップ、チャネルというデータ構造のどれか
ポインタ型＝Cと同じポインタ

・変数の定義（明示的）
var n int
これでint型の変数nとなる。
var x,y,z int
とすればint型の変数x,y,zとなる。
以下のようにすることも可能
var (
    x,y int
    name string
)
この場合、int型の変数x,yとstring型のnameとなる。
定義した変数は＝を使うことで代入できる。同じ型なら再代入に問題はない。
異なる型の値を代入しようとしたらコンパイルエラー。

・変数の定義（暗黙的）
以下のようにすると暗黙的な定義となる。
i := 1
:=が暗黙的に変数を定義する演算子。これを利用すると型推論で型を判別してくれる。
func one() int{
    return 1
}
n := one()
とかの場合は戻り値が変数の型になるのでnはint型になる。
以下の場合はエラーになる。
n := 1
n := 2
:=は代入ではなく変数を定義しているだけのため。
また同じ変数を複数回定義するとエラーが発生する。
再代入したいなら＝を使う。
またvar a = 1のような形で変数を定義することも可能。ただ読みづらいので使わないこと。
複数変数を定義するならvarでまとめた方が良い。
基本的には暗黙的に指定する考え方が正しい選択。

■変数定義の詳細
・パッケージ変数
変数は定義される場所の違いで2種類に分かれる。
ローカル変数＝任意の関数の中に定義された変数
パッケージ変数＝関数定義の外部に定義された変数

package main

import("fmt")

n := 100//パッケージ変数

func main(){
    n = n + 1
    fmt.printf("n=%d\n",n)
}

パッケージ変数はどこからでも読出し書き込みが可能。
なのでパッケージ変数の多様は避けるべき。

・参照されない変数のチェック
Goは変数が参照されているかを厳密にチェックする。
実行すると以下エラーが出る。
.\test001.go:7:2: b declared and not used
.\test001.go:8:2: c declared and not used

buildしようとしても同じ
.\test001.go:7:2: b declared and not used
.\test001.go:8:2: c declared and not used

凡ミス発見の手助けになるのでこういった機能が入っているらしい

■基本型
Goは静的型付け言語のためすべての変数はなんらかの型に属し異なる型同士の演算はコンパイル時に検出される。
基本型は以下の通り
論理値型・・・bool型、trueとかfalse
数値型・・・結構色々分かれる
  整数型
    符号付整数型・・・8ビット、16ビット、32ビット、64ビットで分かれる
    符号なし整数型・・・8ビット、16ビット、32ビット、64ビットで分かれる
    実装に依存する整数型・・・int型、uint型、uintptr型で分かれる。uintptr型はポインタの値をそのまま格納するもの。
暗黙的な型変換を一切許容しない。

整数リテラル・・・10進数、8進数、16進数で表現可能。

・整数の型変換
暗黙的な型変換は行わないが明示的な型変換は行える。
型変換は型(値)で変換可能。
例えば
n := 1の場合
byte(n)
int64(n)
uint32(n)
とかでそれぞれの型に変換される。

変換時にその型の最大値を超えてしまう場合、コンパイルエラーが発生する。
ただし一度intで指定してbyteに変換すると0になる。原因は桁の繰り上がりによる桁あふれ。

・ラップアラウンドへの対策
mathパッケージをインポートし定数を利用して整数のオーバフローをチェックし
オーバーフローしているようであればfalseを返すプログラミングを書けば対策可能。

・浮動小数点型
以下2種類が用意されている
float32＝単精度浮動小数点
float64＝倍精度浮動小数点

浮動小数点の暗黙的な変数定義はfloat64型。
float32型の値を得る場合は明示的な型変換が必要。
浮動小数点の場合、eを区切りとして指数演算することも可能。
例えば1.0e2とすれば100という扱いになる。-を指定すると-乗となる
なので1.0e-2とすれば0.01となる。

浮動小数点の精度は他の言語と同様。
桁を超える場合は使わない方がよい。

浮動小数型から整数型への変換の場合はゼロに向けて小数部が切り捨てられる。
Goにはfloat32とfloat64があるがfloat32は使わない方が良い。

・複素数型
複素数を表す型。iを使用してa + biというリテラルを表現する。
aとbにはそれぞれ実数が入りaを実部、bを虚部と表現する。
実部を取り出す関数がreal、虚部を取り出す関数がimagとなる。

・rune型
Unicodeコードポイントを表す特殊な整数型。
ルーンリテラルはシングルクォートで囲われたUnicode文字で構成される。内容は単なる整数。

・文字列型
String型として定義。ダブルクォートで囲った文字列リテラルが用意されている。

・RAW文字列リテラル
バッククォートで囲まれた範囲を文字列リテラルとする書き方。
特徴は複数行でも書くことが出来る。改行は保持できる。
\nと書いた場合、\とnの文字と判断する。

■配列方
・配列型の定義
書き方は以下の通り
a := [5]int{1,2,3,4,5}
fmt.printf("%v",a)
インデックスに負の値を入れるとエラーになる。
要素数を省略するには...を利用する。
例えば
a := [...]int{1,2,3}とすれば要素数は3になる。
a := [...]int{}とすると要素数は0になる。

要素への代入は指定した要素に代入できる。
互換性のない代入はコンパイル時にエラーとなる。

・配列方の互換性
要素の型が同じでも大きさが違えば代入は出来ない。
代入はあくまでコピーで見ているメモリは違う。

・配列の拡張について
配列型の拡張や縮小は不可能。スライスというデータ構造が可変長配列に相当するのでそれを利用する。

・interface{}とnil
interface{}はどの型とも互換性をもっている特殊な型
初期値はnil
interface変数に格納されると演算は出来なくなる。
nilは具体的な値を持っていない状態を表すもの。

■演算子
演算子は他と変わらず。
文字列結合は＋を使う。

■関数
Goはオブジェクト指向機能を有さない言語。
なので構造体を定義することと関数を定義することがプログラミングの中心

関数定義の基本は以下
func 関数名 ( 引数の定義 ) 戻り値型{
    関数の本体
}

・関数の引数定義
引数の型は1つだけ指定すればよい、というか可能な限り型をまとめること。
以下のように書くことも出来る。
func plus(x int ,y int) int

・戻り値のない関数
戻り値のない関数を持つことも可能。また複数の戻り値を戻すことも可能。
複数の値を返す場合は戻り値の型を(int,int)のように()で囲む必要がある。
()で囲まないとコンパイルエラー。

・戻り値の破棄
_を使えば戻り値を破棄できる。

・関数とエラー処理
例外機構はない。なので任意の関数を呼び出した場合にその処理が成功したかをなんらかの形で検知する必要がある。
エラーが発生したかは戻り値の一部で示す
result,err := doSometing()
if(err != nil){
    //エラー処理
}
doSometingは2つの戻り値を返す。errで受け取っている2番目の戻り値はエラー発生の有無を表している。
変数名をerrにするのも慣例なのでとりあえずこれにしとけば間違いない。

・戻り値を表す変数
例えば以下のようなコードが存在する。
package main
import (
    "fmt"
)
func doSometing() (a int){
    return
}

func main(){
    fmt.println(doSometing())
}
と書くと0が表示される。
これはa int と記載されたところで変数aを整数0で初期化し戻り値にするという処理になる。
ここには複数変数を定義することが出来る。

■無名関数
関数をある種の値として表現したもの。
以下、例
f := func(x,y int) int{return x + y}
f(2,3)
書き方は以下
func (引数リスト) 戻り値型 {無名関数の本体}

名前付き関数と無名関数は定義の仕方に大きな違いはあるが本質的には同じもの。

・関数を返す関数
以下のようにして関数を返す関数を定義できる
package main 
import("fmt")

func returnFunc() func(){
    return func(){
        fmt.pritnln("I'm function")
    }
}
func main(){
    f := returnFunc()
    f()
}
以下のように変数を経由させない書き方もある。
returnFunc()()

関数を引数にとる関数も可能。例は以下
package main 
import("fmt")

func callFunction(f func()){
    f()
}

func main(){
    callFunction(func()
    {
        fmt.println("I'm function")
    })
}

クロージャとしての無名関数
Goの無名関数はクロージャ。
クロージャとは関数閉包とよばれ関数と関数の処理に関係する関数外の環境をセットにしてとじこめたもの。
動くコードは以下
package main
import("fmt")

func later() func(string) string{
    var store string
    return func(next string) string{
        s := store
        store := next
        return s
    }
}

func main(){
    f := later()

    fmt.println(f("Golang"))
    fmt.println(f("is"))
    fmt.println(f("awesome!"))
}
通常、ローカル変数は定義された関数内でのみ利用でき関数の呼び出しが終えたら消えるもの。
ただしクロージャが絡む場合、他のローカル変数とは別にクロージャと結びついた変数として処理する。
なので上の例だとvar store stringとなっているのでstoreのみクロージャと結びついた変数となる。
この場合、クロージャが何らかの形で参照され続けていれば消えることはない。

・クロージャによるジェネレータの実装
Goにはジェネレータの機能はないがクロージャを利用することでそれに似た振る舞いを行う機能を実現できる。
それが以下
package main
import("fmt")

func integers() func() int {
  i := 0
  return func() int{
      i += 1
      return i
  }
}

func main(){
    ints := integers()
    
    fmt.println(ints())
    fmt.println(ints())
    fmt.println(ints())

    otherInts := integers()
    fmt.println(otherInts())
}
クロージャは値を維持するので同じ形で呼び出せば維持した状態で処理が行われる。
別のクロージャにした場合、値は初期化される。

■定数
・const
constを利用することで定数は定義できる。
()を利用して複数設定することも可能。

const (
    x = 1
    y = 2
    z = 3
)
みたいなかんじ。
・値の省略
以下のように省略可能。
const(
    x = 1
    y
    z
)
こう書いた場合、全て1になる。ただし全て省略は出来ない。
定数に式を埋め込むことも出来る。

・定数の型
定数の値として定義できるのは以下
論理値
→TrueかFalseか
整数
→最大値がない。とりあえず256ビットで表現できればOK。ただし通常の変数に代入しようとすると
 あまりに大きい数字だとオーバーフローしてコンパイルできない。
浮動小数点
→仮数部が256ビット、指数部が32ビットまでの浮動小数点を表現できる。
複素数
ルーン
文字列

あくまで各定義できる値を持つ定数でありintなどの型の値を持つ定数ではない。
定数に型を与える場合であれば定数名のあとに型を書く。

・iota
Goには列挙型(複数の定数をひとつにまとめておくことができる型)のような機能はない。
ただiotaを定数定義と組み合わせて使うと似たようなことが出来る。
以下のような書き方
const (
    A = iota
    B = iota
    C = iota
)
定数A,B,Cにそれぞれ0,1,2が割り当てられたことからiotaは0から始まり式として
利用されるたびに1ずつ増分すると理解する。
iotaがない定数を記載しても増加するのでiotaの有無が混在するコードは書かないこと。

■識別子の命名規則
識別子＝変数名、関数名、定数名
使える文字種はUnicodeにおいて文字と定義されたもの、及び数字と定義されたもの。

■スコープ
スコープは大きい順からパッケージ、ファイル、関数、ブロック、制御構文の順。
・パッケージのスコープ
パッケージに定義された定数、変数、関数が他のパッケージから参照できるかは
識別子の1文字目が大文字であるかどうか。
例えば以下
package foo
const(
    A = 1
    abc = "abc"
)
というコードがあった場合、Aは参照可能、abcは参照不可能。
小文字、大文字の識別がない場合は参照不可能。
パッケージで定義されている識別子を参照するにはパッケージ名と識別子を.で繋ぐ。
使う場合はimportでパッケージをインポートする。

・importの詳細
例えば以下の場合
package main
import (
    f "fmt"
)
func main(){
    f.println("Hello World")
}
この場合、f "fmt"でfmtをfに上書きしている状態になる。
パッケージ名を省略するためには.で上書きする。

・ファイルのスコープ
パッケージ定義が複数のファイルによって構成されている場合、import宣言は各々のファイル内でのみ有効になる。

・関数のスコープ
関数の中で定義された変数は関数の中でのみ参照可能。

■制御構文
Goに用意されている制御構文でループを記述するために用意されている構文はforのみ。
条件式をなにも指定しなければ無限ループになる。
書き方は以下
for i := 0; i < 10;i++{

}
・if
ifの構文は以下
if x == 1{

}
else ifとか入ると以下
if x == 1{

}else if y == 1{

}else{

}
ifの条件式は必ずbool値である必要がある。

・簡易文つきif
以下のような形で書くことも可能
if x,y = 1,2;x<y{

}
簡易文の利用の仕方のひとつとしてスコープを小さくすることが出来る。
ifで定義したところでのみ利用可能なので変数が重複しても問題が発生しない。

・for
breakを指定することで一番近い位置のforが中断できる。

・条件付for
i := 0
for i < 100{
    fmt.pritnln(i)
    i++
}
これで100までループ
・古典的for
以下の形でforもかける
for 初期化文;条件式;後処理文;{
    処理内容
}
・continue
ループ内で残処理をスキップして次の処理へいく

・範囲節によるfor
rangeと任意の式を組み合わせて定義する。
例えば
fruits := [3]string{"apple","Banana","Cherry"}
for i , s := range fruits{
    fmt.println(s)
}
みたいな感じ。
・配列型とrange
配列型のrangeは1番目の反復値に配列のインデックス、次が要素となる。

・文字列とrange
文字列は文字に対して実行される。
なのでインデックスとルーンが変える。

・switch
式によるswitchと型によるswitchの処理がある
・式によるswitch
書き方は以下
switch 簡易文; 式{

}
例えば
n := 3
switch n {
    case 1,2:
        fmt.println("1 or 2")
    case 3,4:
        fmt.println("3 or 4")
    default:
        fmt.println("unknown")
}
breakは必要ない。
フォールスルーが必要ならfallthroughを明示的に記載する。
ifやswitchで使える簡易文は変数の局所性を高めるための重要な機能なので
積極的に活用すること。
またswitchに式を伴うcaseを書くことも可能。
ただしcaseに定数と式が混ざっている場合はコンパイルエラー。

・型アサーション
型アサーションとは？
動的に変数の型をチェックするGoの重要な機能の1つ
以下のようなソースだと様々な引数が取れる
fuc anything(a interface{}){
    fmt.println(a)
}
以下のような形で型アサーションが可能
var x interface{} = 3
i := x.(int)
f := x.(float64)
この場合、iには整数3が代入されるが3は浮動小数点ではないのでfの場合コンパイルエラー

以下の書き方もある。
var x interface{} = 3
i, isInt := x.(int)
f, isFloat64 := x.(float64)
s, isString := x.(string)

この場合、成功すれば１番目の変数にはその値が、2番目の変数にはtrueが入る。
なので型アサーションの失敗を検知することが出来る。

■型によるswitch
switch x.(type)を利用することで型によるswitchが可能。

■goto
goto文はラベルと組み合わせて使用する。
変数定義を超える場合はエラー。

・ラベル付き文
Goのラベルをforループなどの構造をもった文と組み合わせて使用することで
複雑な処理フローを分かりやすく記述できる。

■defer
deferを利用すると関数の終了時に実行される式を登録できる。
func runDefer(){
    defer fmt.println("defer")
    fmt.println("done")
}
runDefer()

この場合、deferの出力が最後になる。
defer文に登録できる式はcallFunc()のように関数呼び出し形式の式に限られる。
登録自体はいくつでも可能。
ただしあとで登録された順から実行される。
使うタイミングは例えばリソース開放など。

■panicとrecover
・panic
panicを実行すると即座にランタイムパニックを発生させ実行中の関数を中断する。
一般的なエラーでは利用しないこと。

・recover
panicによって発生したランタイムパニックによるプログラムの中断を回復する。

■go
go文は並行処理をつかさどる機能。
go文はdefer文と同じく関数呼び出し形式の式を受けとる。
Goはスレッドよりも小さい処理単位であるゴルーチンが並行して動作するように実装されている。
go文はゴルーチンを新たに生成して並行して処理される新しい処理の流れをランタイムに追加するための機能。

■init
initはパッケージの初期化を目的にした関数。
関数initはmainよりも早く実行するので初期化処理を行うのに便利。
