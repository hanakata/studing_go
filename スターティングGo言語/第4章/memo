第4章 参照型
参照型とは？
事前に定義されている型でスライス、マップ、チャネルという3つがある。
参照型の生成には組み込み関数makeを必ず利用する。

■スライス
最も利用頻度の高いデータ構造でいわゆる可変長配列を表現する型。
スライスを表す型は以下のように表現する。
var s []int
変数sはint型を格納するスライスであることが宣言されている。
以下のように要素数と容量が10であるint型のスライスを生成する。
s := make([]int , 10)
スライスと配列は共通点が多いので同じように見える。

・要素への代入と参照
代入と参照は配列型と同様に[n]を利用してインデックスを使用。
スライスの要素数を超過した要素へのアクセスはランタイムパニックを発生させる。

・len
スライスの要素数を調べる関数。

・cap
スライスの容量を調べる関数。
スライスの要素数は既に数値が入っているもの容量は全体の大きさ。
スライスをmakeで作成するときに第3引数で設定することが出来る。
要素数と同じ数字でなくても良い。

容量を多めに取っておくと想定以上のメモリ領域確保は発生しない。
用意しておいた容量を超える要素を与えると別のメモリ領域にそれだけの
容量を用意しそこに既存のスライスをコピーして追加するという動作になる。
容量が事前に分かっているような状況であれば容量は正しく確保しておくこと。

・簡易スライス
配列型かスライスを指す変数に[n:m]という形式の範囲を表すパラメータを渡すことでインデックスのnからm-1までの
要素をもつスライスを生成可能。

・文字列と簡易スライス
以下のような書き方をすると文字列の一部を抜き出すことが出来る。
s := "ABCDE"[1:3]
この場合、sはBCとなる。

・append
配列とスライスの違いは拡張性。
配列は拡張性がない。スライスは拡張するときにappendを利用することが出来る。
使い方は以下
s := []int{1,2,3}
s = append(s,4)
s = append(s,5,6,7)
スライスにスライスの要素を追加することも可能。
s0 := []int{1,2,3}
s1 := []int{4,5,6}
s2 := append(s0,s1...)
2番目の引数がs1...というような書き方になる。

・appendとスライスの容量
容量が不足したタイミングでスライスの容量が倍増されていく。

・copy
copy関数はスライスにスライスの値を一括でコピーするための関数。
使用方法は1番目の引数に指定したスライスをコピー先として2番目に
指定したスライスの内容をコピー先の内容に上書きする。
要素数が5のものに対し2のものをコピーしたら最初の2つ目までが
上書きされてその他はそのまま残る。

・完全スライス式
スライス式には3つのパラメータをとる完全スライス式というものがある。
整数3つを:で区切って並べる。
各々のパラメータは以下の関係性である必要がある。
0<=low<=high<=max<=cap
簡易スライスとの違いはmaxの指定によって容量をコントロールできること。
構文は以下
a[low:high:max]

・スライスとfor
rangeを使った範囲節によってスライスの要素数を気にすることなく全要素に対するループ処理が可能
s := []string{"Apple","Banana","Cherry"}

for i,v := range s{
    fmt.Printf("[%d] => %s\n",i,v)
}
・スライスと可変長引数
fmt.printfのような関数は任意個数の引数を取ることが出来る。
これを実現するためにスライスが利用されている。
s ...intという引数の定義を利用することによって全ての値を[]int型のスライスにまとめる指定として機能する。

・参照型としてのスライス
配列型を使った関数powの場合、
func pow(a [3]int){
    for i,v := range a{
        a[i] = v * v
    }
    return
}
func main(){
    a := [3]int{1,2,3}
    pow(a)
    fmt.Println(a)
}
この場合、意図通りに動作しない。
理由はpow(a)という配列型を引数にとった関数の呼び出しでは引数は値渡しによってコピーされ
関数main内の変数aとpow内のaは別のものだから。
func pow(a []int){
    for i,v := range a{
        a[i] = v * v
    }
    return
}
func main(){
    a := []int{1,2,3}
    pow(a)
    fmt.Println(a)
}
参照型にすることで意図通りに動作するようになる。

・スライスの落とし穴
自動拡張は結構ネックなので注意して利用すること。

■マップ
連想配列に類するデータ構造
マップを表す型はmap[キーの型]要素の型で表す。
var m map[int]string
これもスライス同様にmakeで生成される。
マップは一意に定まるキーと任意の要素の組み合わせで構成されるので
キーの値が重複する代入を行うと要素は上書きされる。

・マップのリテラル
マップの型名のあとに｛｝で囲ってキーと要素のペアを任意の数だけ書くことが出来る。
m := map[int]string{1:"taro",2:"jiro",3:"Hanako"}みたいな形。

マップを生成するリテラルの内部にさらにスライスを生成するリテラルを含めることも可能。
当然ながらmapの中にmapを作成することも可能。

・要素への代入と参照
マップの要素を参照するには演算子[]を利用してキーを指定する。
キーがない場合はString型の空文字が代入される。
この仕様がエラーを発生させやすいので2つの変数へ代入させ2番目の変数が
trueかfalseかを判別すればエラーは回避できる。

マップはnilを指定可能。

・マップとfor
書き方はスライスと一緒。マップの場合、キーの順序は保持されない。

・len
mapの要素数を整数で取得できる。ただしcapは利用できない。

・delete
要素を削除する。

■チャネル
チャネルはゴルーチンとゴルーチンの間にデータの受け渡しをつかさどるためのデータ構造。

・チャネルの型名
chan [データ型]で表現する。
var ch chan int
<-chanは受信専用チャネル
chan<-は送信専用チャネル
基本はchanを利用し状況に応じて<-chanやchan<-を利用する。

・チャネルの生成と送受信
チャネルもmakeで生成する。
チャネルはキューの性質を備えるデータ構造。チャネルのバッファはキューの格納領域。
チャネルが保持するデータに対する操作は送信か受信の2パターンのみ。

・チャネルとゴルーチン
チャネルは単なるキューではなくゴルーチン間のデータ共有が目的。
チャネルから受信するという処理は他のゴルーチンがチャネルへデータを送信するのを待つもの。
なので受信だけある場合、ランタイムパニックを起こす。

・len
lenで取得できるのはチャネルのバッファ内に溜められているデータ個数。

・cap
capで取得できるのはチャネルのバッファサイズ。

・close
チャネルがmakeされたときはopen、それをクローズする。
クローズしているチャネルに送信を行うとランタイムパニックが起きる。
クローズしてもバッファ内にデータがある場合は送信をし続ける。
受信可能かをチェックすること。チェックする場合は2つの変数に代入し2番目の変数をチェックする。

・チャネルとfor
チャネルからひたすら受信し続ける処理なら有用。

・select
selectを利用することで複数のチャネルに対する受信、送信処理で停止させることなくコントロールが出来る。

