第2章 プログラム構造
■名前
Goで指定できる名前関連は文字もしくはアンダースコア。
大文字、小文字の区別あり。
関数内で宣言されたものはその関数に対してローカル。
関数外で宣言されたもので小文字で始まればローカル、大文字で始まればグローバル。
Goで用いられる名前の長さは短いのが慣習。
特にスコープが狭いローカル変数だとより短い。
またGoで単語を組み合わせて名前を付ける場合はキャメルケースにする。

■宣言
宣言に必要なのはvar、const、type、funcの4種類。
goプログラムは拡張子goで終わりどのパッケージに属するかはpackageで指定する。
以下のプログラムの場合、
const boilingF = 212.0

func main() {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %gF or %gC\n", f, c)
}
定数であるboilingFはパッケージレベルの宣言。
変数、fとcは関数に対してローカル。
関数の宣言は、名前、パラメータのリスト、省略可能な結果のリスト、関数本体を持つ。
関数の実行は最初からreturnまでかなければ関数の最後まで実行される。

■変数
var宣言は特定の型の変数を作成しその変数に名前を結びつけて初期値を設定する。
一般形式は以下。
var name type = expression

typeか= expressionのどちらかは省略できる。両方は無理。
typeが省略された場合は型が初期値によって決まる。
初期値が省略された場合は型に対するゼロ値が入る。なのでGoの変数に初期化されていないものはない。
単一宣言で複数の変数を宣言したり型を省略することによって異なる型の複数変数宣言が可能になる。
var i,j,k int
var b,f,s = true,2.3,"four"
初期化されるタイミングはパッケージレベルの場合、mainの前。
ローカル変数は関数の実行中に宣言に出会ったとき。
・省略変数宣言
省略変数宣言は以下の式で可能。
name := expression
nameの型はexpressionの型で決まる。
簡単で柔軟なのでローカル変数の大多数が省略変数宣言を使った宣言で初期化される。
var宣言はローカル変数の型が初期化子式の型と異なるため明示的な型を必要とする場合や
後で値が代入されて初期値が重要でない場合に使われる傾向が強い。

複数の初期化子式は可読性が向上するときのみ使う。
:=は宣言で=は代入である。
省略変数の場合、左辺の変数のどれかが既に同じレキシカルブロック内で宣言されている場合、
その変数に代入する動きとなる。

・ポインタ
変数は値を含んでいる記憶域であり名前で特定される。
ポインタの値は変数のアドレスなので名前を使わずに間接的に読み取ったり更新したり出来る。
例えば変数がvar x intとなっている場合、式&x(xのアドレス)は整数変数へのポインタ*int型の値を生じる。
変数はアドレス化可能な値といわれる。変数を表す式はアドレス演算子である&が適用できる式のみ。
ポインタのゼロ値はnil。
ポインタはflagパッケージにとって重要。flagパッケージはプログラム全体に分岐しているある種の
変数の値を設定するためにプログラムのコマンドライン引数を利用する。
flag.Bool関数はbool型の新たなフラグ変数を生成。
3つの引数としてフラグ名、変数のデフォルト値、メッセージを意味する。
メッセージは引数として不正な値や-h、-helpを渡した場合に表示される。
var n = flag.Bool("n", false, "omit trailing newline")
flag.Stringは名前、デフォルト値、メッセージを受け取り
string型の変数を生成。
var sep = flag.String("s", " ", "separator")

プログラムが実行されるときフラグ変数をそのデフォルト値から更新するため、
フラグを使う前にflag.Parseを呼び出す。

・new関数
変数を作成する別の方法はnew関数を利用すること。
new(T)とするとT型の無名変数を作成しTのゼロ値へ初期化し*T型の値であるそのアドレスを返す。
newで作成された変数はダミーの名前を考えて宣言する必要がないこと以外はアドレスが取得された
ローカル変数と同じ。
newはほぼ使われない。構造体型の構造体リテラル構文の方が柔軟であるため。

・変数の生存期間
変数の生存期間とはプログラムを実行する際にその変数が存在する期間のこと
パッケージレベルであればプログラムの実行全体、ローカル変数は動的な生存期間。
変数は到達不可能になるまで生存する。
ガベージコレクタがメモリ領域を回収する判断を行うのはポインタと他の種類の参照をたどることで
変数へ到達しない場合に回収を行う。

■代入
代入文の単純な形式は=記号の左辺に変数があり、右辺に式ある形。
代入演算子は以下のように書くことが出来る。
count[x] *= scala
++とか--とかでインクリメント、デクリメントが可能。

・タプル代入
複数の変数へ一度に代入すること。
変数の中身を入れ替えるときに便利。
x,y = y,x
また2つの数字の最大公約数を計算するには
func gcd(x,y int) int {
    for y != 0{
        x,y = y , x%y
    }
    return x
}

n番目のフィボナッチ数を計算するには
func fib(n int) int{
    x,y := 0,1
    for i := 0;i < n; i++{
        x,y = y,x+y
    }
    return x
}
のような形でタプル代入が役に立つ。
ただし式が複雑な場合はタプル代入は避けること。読みづらい。

関数として結果を2つ返す場合には2つの変数に代入するよう準備すること。
使わない場合は_を利用する。

・代入可能性
代入が暗黙的に行われていることがプログラム内ではよくある。
例えば関数を呼び出したときなど。
変数に対し代入可能かを確認すること。

■型宣言
変数や式の型はその型が取る値の性質を定義する。
type宣言は既存の型と同じ基底型をもつ新たな名前付き型を定義する。

型宣言は基本的にパッケージレベルで書く。
名前を付けることによって例えば同じfloat64であっても別の型になるので間違えることがなくなる。

型変換も行うことが出来るが別の型に変換した場合、データが崩れる可能性がある。
例えばfloat->intの場合、小数点以下は破棄される。

■パッケージとファイル
Goのパッケージは他の言語でのライブラリやモジュールと同じ目的を提供し、モジュール性、カプセル化、分離されたコンパイル、再利用をサポートする。
パッケージは公開するか制御するか決められる。

・インポート
すべてのパッケージはインポートパスと呼ばれる一意の文字列で特定される。
インポートしたパッケージを参照していないとエラーになる。
なので必要に応じて自動的にインポートパッケージを修正するツールを入れたほうが開発が早くなる。

・パッケージ初期化
宣言されている順番で初期化されていくが以下の場合は依存関係のため最後のcが1番最初に初期化される
var a = b + c
var b = f()
var c = 1

変数によって初期化式による初期化が難しい場合がある。ex)テーブルとか
その場合init関数を利用することで初期化できる。
init関数は呼び出すことも参照することも出来ないがそれ以外は普通の関数。

PopCount関数はuinit64の値にセットされているビット数を返す。

■スコープ
宣言は名前とプログラムのエンティティを関連付ける。
宣言のスコープとは宣言された名前の使用にあたり当の宣言を参照するようなソースコードの範囲。
スコープと生存期間は別。
スコープ＝プログラムテキストの範囲、コンパイル時の特性。
生存期間＝変数がプログラムのほかの部分から参照できる実行時の範囲、実行時の特性。

構文上のブロックは波括弧で囲まれた一連の文。
ブロック内で宣言された名前はブロック内でしか見えない。
ソースコードで明示的に波括弧で囲まれない宣言のほかのグループもブロックの概念に入る。
これら全てをレキシカルブロックと呼ぶ。
ユニバースブロックはソースコード全体。
レキシカルブロックが違えば同じ変数名は使える。
