第9章 共有された変数による並行性
■競合状態
ゴルーチン内のイベントxがyより前か、あとか、同時かは分からない。
その場合、xとyは並行であるといえる。
並行で動作している場合、正しく動作し続けるのであれば並行的に安全といえる。
並行に変数へアクセスする場合は単一のゴルーチンに閉じ込めるか相互排他するかで制御する。

制御されていない場合、データが競合状態に陥る場合がある。

■相互排他：sync.Mutex
相互排他としてsyncパッケージのMutex型がサポートしている。
Lockメソッドはトークンを獲得しUnlockメソッドはそれを解放する。

Lockメソッドを呼び出すことで変数をロックすることが出来る。
なので編集するときはLockし終わったらUnlockすることで競合は防げる。

■競合検出器
go buildやgo run、go testのコマンドに引数-raceフラグを追加することで競合検出が可能になる。

■ゴルーチンとスレッド
OSスレッドは固定の大きさのメモリをスタックとして持っている。
→実行中の関数呼び出し、他の関数が呼ばれている間は一時停止している関数呼び出しでのローカル変数が保存されている活動領域。

ゴルーチンのスタックは固定された大きさではなく必要に応じて伸長可能になっている。

OSスレッドはOSカーネルによってスケジュールされている。
GoのスケジューラーはGo言語の構造によって暗黙的に起動される。

GoのスケジューラはGoのコードを能動的に同時に実行できるOSスレッドが何個かを決めるGOMAXPROCSと呼ばれるパラメータを使う。

