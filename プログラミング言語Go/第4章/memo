第4章 コンポジット型

■配列
配列は特定の型の0個以上の固定長列。固定長なのであまり使われない。使うならスライス。
値のリストで配列を初期化するために次のように配列リテラルを使う。
var q [3]int = [3]int{1,2,3}
var r [3]int = [3]int{1,2}
配列リテラルで省略記号...が長さの場所に書かれている場合、配列長は初期化子の数で決まる。
q := [...]int(1,2,3)
この場合[3]intとなる。
インデックスと値の組のリストを指定することも出来る。（辞書型みたいな）
配列の比較は全ての対応する要素が等しいかどうかを確認する。

%xはバイト配列、あるいはスライスの要素を全て16進数で表す。
%tはブーリアン
%Tは値の型

配列要素に対して関数が行った変更が呼び出しもとに見えるようにするために配列へのポインタを明示的に渡すことが出来る。

■スライス
スライスはすべての要素が同じ型である可変長列を表す。スライスの型は要素がT型なら[]Tと書く。
スライスは配列の要素の部分列へアクセスする軽量なデータ構造。
こういった配列をスライスの基底配列と呼ぶ。
スライスはインデックスを指定できる。例えば
months := [...]string(1:"January",12:"December")
とした場合、months[1]はJanuary、months[12]はDecemberとなる。
months[0]などは空文字に初期化される。
capsの容量を超えた場合エラーとなる。
lensの場合は容量の範囲内で拡張される。

組み込みのmake関数は指定された型、長さ、容量のスライスを作成する。
容量は省略できる。

・append関数
append関数はスライスに項目を追加する。

・スライス内での技法
rotateやreverseなどスライス内でその要素の修正を行うことが出来る。
入力スライスと出力スライスは同じ基底配列を参照している。
なので出力スライスの結果に入力スライスも影響する。
スタックを実装するにはスライスが使える。

■マップ
ハッシュテーブルはすべてのデータ構造の中で最も精巧で用途が広いもの。
Goではマップはハッシュテーブルへの参照。
組み込み関数makeを利用してマップを作成できる。
ages := make(map[string]int)
マップリテラルを利用しても可能。
ages := map[string]int{
    "alice": 31,
    "charlie": 34,
}
要素へのアクセスはインデックスを利用して。
削除は組み込み関数であるdeleteを利用。

マップ要素に対してx += yなど可能なので
ages['bob'] += 1
とかも可能。
マップの要素は変数ではないのでアドレスを得ることはできない。
マップ内の全てのキーと値を列挙するためにはfor文を利用する。

■構造体
構造体は合成データ型であり0個以上の任意の型の名前付き値を単一エンティティにまとめる。
それぞれの値はフィールドと呼ばれる。
例としては以下の通り
type Employee struct{
    ID int
    Name string
    Address string
    DoB time.time
    Position string
    Salary int
    ManagerID int
}
var dilbert Employee
それぞれのフィールドへはdilbert.IDとかでアクセスする。
dilbertは変数。
同じ型の連続するフィールドはまとめることが可能。

構造体型の値はそのフィールドに対する値を指定する構造体リテラルを使ってかける。
type Point struct{X,Y int}
p := Point{1,2}
この形はそれぞれ正しい値を正しい順序で入れる必要があるのでフィールドを覚えておく必要がある。
→あまり使わない。順序が確定しているときのみ。
なのでフィールド名とそれに対応する値のいくつかを列挙して構造体の値を初期化する。

ポインタを利用して間接的に関数に渡したり返されたりすることも可能。
構造体のすべてのフィールドが比較可能であれば構造体自身も比較可能。

Goには構造体埋め込み機構があり、他の構造体の無名フィールドとして名前つき構造体型を使うことが出来る。
以下例で使用する構造体
type Circle struct {
    X,Y Radius int
}
type Wheel struct {
    X,Y Radius,Spokes int
}
この場合、値を指定するには以下でいける
var w Wheel
w.X = 8
w.Y = 8
w.Radius = 5
w.Spokes = 20
こうなると類似点とか共通点とか出てくる。なのでまとめると
type Point struct{
    X,Y int
}
type Circle struct {
    Center Point
    Radius int
}
type Wheel struct{
    Circle Circle
    Spokes int
}
と出来る。この場合、以下の形でアクセスできる。
var w Wheel
w.Circle.Center.X = 8
w.Circle.Center.Y = 8
w.Circle.Radius = 5
w.Spokes = 20

型を持つが名前を持たないフィールドを無名フィールドと呼ぶ。
無名フィールドの型は名前つき型かポインタでないとダメ。
以下のような使い方。
type Circle struct {
    Point
    Radius int
}
type Wheel struct{
    Circle
    Spokes int
}
こういった形にすることで中間の名前を書くことなく暗黙の木の葉の部分に当たる名前を参照することが出来る。

■JSON
JSONは構造化された情報を送受信するための標準表記。
JSONを利用するにはencoding/jsonを利用するのがよい。

■テキストテンプレートとHTMLテンプレート
フォーマットが複雑なときはtext/templateやhtml/templateなどを使って
コードからフォーマットを完全に分離すべき。
