第2章 構文解析
■構文解析器（パーサー）
構文解析器は入力をあるデータ構造へと変換するもの。
ほとんどのインタプリタやコンパイラにおいてソースコードの内部表現として使われるのは構文木、抽象構文木と呼ばれるもの。
どんな構文解析器でも利用できるような抽象構文木は存在しない。

■パーサジェネレータじゃないの？
パーサージェネレータはなんらかの言語の形式的記述を受け取って
出力としてパーサーを出力する。
その出力はコンパイルしたりインタプリタで実行したり出来る。
パーサージェネレータではあるし、プロダクトとして作成するなら
そっちを使った方がよいが学習することで理解が深まるので今回は利用しない。

■Monkey言語のための構文解析器を書く
構文解析は以下の2種類
・トップダウン構文解析
・ボトムアップ構文解析
今回はトップダウン構文解析器の再帰下降構文解析器。

■構文解析器の第一歩：let文
let文は与えられた名前を値に束縛する。

以下のインターフェイスが存在する。
・Node
→ノードが関連付けられているトークンのリテラル値を返す。
・Statement
・Expression
ASTの全てのノードはNodeインタフェースを実装しなければならない。
すなわちTokenliteral()メソッドを提供する必要がある。

let x = 5;という形式の変数束縛のノードはどういうものか。
どういうフィールドが必要か？
l→字句解析器インスタンスへのポインタ
以下2つは字句解析にあった2つのポインタのように動作する。
curToken→現在調べているトークンであり、次に何をすべきかを判断する。
peekToken→curTokenだけで十分な情報が得られない場合に利用。

構文解析器はoff-by-oneエラーの温床になりやすいのでテストとアサーションは多ければ多いほどよい。
Off-by-oneエラー（オフ-バイ-ワンエラー、off-by-one error、OBOE）とは、境界条件の判定に関するエラーの一種である。
コンピュータプログラミングにおいて、ループが正しい回数より一回多く、または一回少なく実行された場合などに発生する。

■return文の構文解析
return文はreturnと式で構成される。

■式の構文解析
式の構文解析は文の構文解析よりも比較的難しい。
理由として四則演算の優先順位が上げられる。

pratt構文解析の考え方で重要なのはトークンタイプごとに構文解析関数を関連付けること。
あるトークンタイプに遭遇するたびに対応する構文解析関数が呼び出される。
